[{"categories":[],"contents":"前言 本文說明如何在 Synology NAS 上使用 rclone 這套工具，搭配 pCloud 這個雲端來做到雲端方案的端對端加密備份，讓資料的保障更上一層樓\n安裝 rclone 這邊以 macOS 為例, 透過 brew 安裝 rclone\nbrew install rclone Synology NAS 的部分，本文會使用 docker 來執行 rclone, 因此無須在 Synolog 的 host 上面安裝 rclone\n設定 rclone remote for pCloud 這個步驟是為了讓 rclone 取得存取 pCloud 的權限\nssh 進 Synology, 透過 docker 執行 rclone config\ndocker run --rm -it --volume /volume1/docker/rclone/config:/config/rclone --user $(id -u):$(id -g) rclone/rclone config 這邊請透過 volume 選項將 rclone 的 rclone.conf 設定檔放到你想放的 NAS 位置，如果沒加 volume 的話 rclone.conf 會放在 container 內，這樣就沒辦法保存設定給後面的備份設定使用，例如這邊的範例是我將 config 檔保存在 /volume1/docker/rclone/config 中，這樣一來在後面的 rclone 備份指令中就可以沿用這個步驟設定完成的 rclone.conf\n進到 rclone 的互動式介面後，選擇 New remote，接著按照系統提示一步一步設定 pcloud remote (storage type 選擇 42 代表要加入 pcloud)\n42 / Pcloud \\ (pcloud) 範例設定如下 (client_id, client_secret 留空即可)\nStorage\u0026gt; 42 Option client_id. OAuth Client Id. Leave blank normally. Enter a value. Press Enter to leave empty. client_id\u0026gt; Option client_secret. OAuth Client Secret. Leave blank normally. Enter a value. Press Enter to leave empty. client_secret\u0026gt; Edit advanced config? y) Yes n) No (default) y/n\u0026gt; n Use web browser to automatically authenticate rclone with remote? * Say Y if the machine running rclone has a web browser you can use * Say N if running rclone on a (remote) machine without web browser access If not sure try Y. If Y failed, try N. y) Yes (default) n) No y/n\u0026gt; N Option config_token. For this to work, you will need rclone available on a machine that has a web browser available. For more help and alternate methods see: https://rclone.org/remote_setup/ Execute the following on the machine with the web browser (same rclone version recommended): rclone authorize \u0026#34;pcloud\u0026#34; Then paste the result. Enter a value. config_token\u0026gt; 到了 Option config_token 這步，由於 Synology NAS 沒有 Web browser, 因此選擇 n，我們回到 macOS, 使用以下指令進行認證\nrclone authorize pcloud 瀏覽器會跳轉到 pcloud 的登入頁面，登入成功後瀏覽器會顯示一個 access token，將這個 access token 貼回 Synology 的 rclone config 中就設定完成了\n完成後 NAS 的檔案總管上在你指定的 volume 底下的 folder 預期可以得到一份 rclone.conf，請把這個檔案備份好\n設定 rclone crypt remote pcloud 順利讓 rclone 取得 pcloud 的存取權限後，接下來我們要在 rclone 開一個 crypt remote, 把 pcloud 的指定路徑變成我們的端對端加密備份的路徑\n在 Synology 上透過 docker 執行 rclone config\ndocker run --rm -it --volume /volume1/docker/rclone/config:/config/rclone --user $(id -u):$(id -g) rclone/rclone config 選擇 New remote，remote name 輸入 pcloud_crypt，Storage type 選擇 crypt\n15 / Encrypt/Decrypt a remote \\ (crypt) 接著會要你輸入想要 encrypt/decrypt 的 remote 以及 path\nStorage\u0026gt; 15 Option remote. Remote to encrypt/decrypt. Normally should contain a \u0026#39;:\u0026#39; and a path, e.g. \u0026#34;myremote:path/to/dir\u0026#34;, \u0026#34;myremote:bucket\u0026#34; or maybe \u0026#34;myremote:\u0026#34; (not recommended). Enter a value. remote\u0026gt; remote 就輸入你前面步驟設定的 pcloud remote (這裡的 remote name 以 pcloud 為例)，path 的部分，需要指定一個路徑，rclone 會在 pcloud 上面建立這個路徑的 folder, 並將這個 folder 作為 rclone 使用，因此若你平常就有在使用 pcloud 存放檔案的話，強烈建議一定要指定路徑，否則 rclone 會將整個 plcoud 的根目錄都拿來使用\n這邊我指定了 nas_backup 這個路徑，這樣一來在之後透過這個 remote 操作備份時，rclone 就會在 pcloud 的根目錄建立 nas_backup 這個 folder 並將我們的檔案加密後放進這個 folder 中\nOption remote. Remote to encrypt/decrypt. Normally should contain a \u0026#39;:\u0026#39; and a path, e.g. \u0026#34;myremote:path/to/dir\u0026#34;, \u0026#34;myremote:bucket\u0026#34; or maybe \u0026#34;myremote:\u0026#34; (not recommended). Enter a value. remote\u0026gt; pcloud:nas_backup 接著設定是否要加密檔案名稱 （預設加密）、是否要加密資料夾名稱（預設不加密），這邊依照個人偏好設定即可\n接著最重要的一步：設定你的的加密金鑰 (password)\nOption password. Password or pass phrase for encryption. Choose an alternative below. y) Yes, type in my own password g) Generate random password 可以選擇自己設定一個或是系統幫忙產一個 random password, 不論選哪一種，都請將這個加密金鑰備份好，否則將來無法解開你的備份檔案\n後續還有一些進階保護的設定選項，例如是否要為你的 password 添加一個 salt、是否要加密 rclone.conf 等等，可根據個人需求參考官方文件去設定，本文不再贅述。\n設定完成儲存後，在 rclone config 就可以看到我們成功新增了一個 crypt remote，至此 remote 的部分已經全數設定完畢，可以開始使用 rclone 備份資料了\n使用 Docker Compose 執行備份 在這個步驟，我們要設定以下這個 docker-compose.yml 來當作我們的自動備份 task\nversion: \u0026#34;3.9\u0026#34; services: rclone-foobar: image: rclone/rclone:latest container_name: rclone-foobar environment: - TZ=Asia/Taipei volumes: - /volume1/foobar:/data:ro # backup target - /volume1/docker/rclone/config:/config/rclone # rclone.conf - /volume1/docker/rclone/logs:/logs # log files - /volume1/docker/rclone/scripts:/scripts # backup script # For Synology NAS, use the following entrypoint to run a custom script entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;/scripts/backup-foobar.sh\u0026#34;] 有幾個設定的重點，皆透過 docker volume 進行\n備份目標資料夾 (e.g. /volume1/foobar) rclone.conf 位置，把前面步驟設定 pcloud 產生的 rclone.conf 儲存在你要的地方並將 NAS 上的檔案路徑 (e.g. /volume1/docker/rclone/config) 正確的 map 到 container 的 /config/rclone 這個路徑 log file 存放位置：為了日後備份失敗時可以 debug, 因此可以在 NAS 上開一個 log 資料夾給 rclone 使用 備份 script 路徑 (e.g. /volume1/docker/rclone/scripts) : 用來執行 rclone sync 指令，是備份主要的觸發點，將要執行的備份 script 透過 entrypoint 設定進 compose 中 範例的備份 script (backup-foobar.sh) 如下\n#!/bin/sh # This script is executed every time the container starts # Can be used with DSM scheduler to start the container daily and trigger automatic backup LOG_FILE=\u0026#34;/logs/rclone.log\u0026#34; echo \u0026#34;=== Rclone backup started at $(date) ===\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; # Upload data to the encrypted remote rclone sync /data pcloud_crypt:nas_backup \\ --transfers=2 \\ --checkers=4 \\ --exclude-from=/config/exclude_list.txt \\ --log-file=\u0026#34;$LOG_FILE\u0026#34; \\ --log-level=INFO echo \u0026#34;=== Rclone backup completed at $(date) ===\u0026#34; \u0026gt;\u0026gt; \u0026#34;$LOG_FILE\u0026#34; script 中的 /data 會透過 docker volume 指向你的備份目標資料夾，而 pcloud_crypt:nas_backup 就是剛剛我們在建立 crypt remote 時的 remote name 以及路徑 --transfers 和 --checkers 可以根據個人的網路能力及需求設定，log 稍候可以透過 docker volume 的方式儲存在 NAS 上面以供日後 debug 接著我們設定檔案排除以及 logrotate 兩個功能\n設定排除檔案 Synology NAS 的資料夾會有一些 synology 專用的索引檔案可以不用備份，我們可以透過 --exclude-from 來設定這些 ignore file list，以下附上我從網路上找到用來 ignore Synology 檔案的清單：\n@eaDir/** #recycle/** Thumbs.db desktop.ini .DS_Store ._* .SynologyWorkingDirectory/** 設定 logrotate 上面的 docker-compose.yml 範例，我們將 rclone 產生的 log 存在 /volume1/docker/rclone/logs/ 中，為了必面日後 log 大小過大，因此我們利用 linux 的 logrotate 來處理 log 檔案的自動 rotate\n在 NAS host 上新增一個 logrotate 設定\nsudo vi /etc/logrotate.d/rclone 範例設定如下，細部設定可以依照個人需求調整\n/volume1/docker/rclone/logs/*.log { daily rotate 7 compress delaycompress missingok notifempty copytruncate size 50M maxage 14 } 測試是否能手動 rotate\nsudo logrotate -f /etc/logrotate.d/rclone 測試 全部設定完成後，可以 ssh 進 NAS 確認 docker-compose 是否能順利執行：\ndocker-compose up 執行完畢後，container 會自動 exit，檢查 log 無異狀並且檔案有成功上傳到 pcloud 的話就表示成功了 可以順便在 pcloud 上面看你的檔案有沒有被成功的加密\n透過 DSM 自動化排程備份 在前面的步驟中，我們已經寫好了一個可以手動進行端對端加密備份的 docker-compose.yml 了，下一步就是要將備份自動化，融入日常的 NAS 任務中，我們要利用 DSM 的 排程任務 (Task Scheduler) 來作這件事情\n建立 rclone user 首先，為了防止 rclone 的權限過大，因此我們在 NAS 上為 rclone 建立一個獨立的 user, 來限制 rclone 能存取的資料夾以及讀寫權限，目標是只讓 rclone 可以讀我們的備份目標資料夾以及 docker 的執行權限，其他沒有要透過 rclone 備份的資料夾，該 user 無法存取\n在 DSM 的控制台新增一個名為 rclone 的 user, 並將其加入 docker 這個 group，讓這個 user 可以不用透過 sudo 執行 docker (如何在 Synology 上建立 docker group 可以參考我之前寫的這篇如何在 Synology NAS 使用 non-root user 執行 Docker command)\n資料夾權限、應用程式權限預設全部禁止存取，之後根據個人需求允許個別的資料夾權限就好\n新增 DSM 排程任務 接著在 DSM 控制台的「任務排程表 (Task Scheduler)」建立一個任務\n使用者設定 rclone 指令欄位輸入 docker-compose up 指令來執行我們上面步驟寫好的 yaml，範例如下：\ndocker-compose -f /path/to/your/docker-compose.yml up 設定好排程時間後就大功告成了，現在你的 NAS 已經實現了一個端對端加密的雲端異地備份服務\n","date":"November 22, 2025","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/rclone-pcloud-backup/","summary":"使用 Docker 版 rclone 將 Synology NAS 的資料端對端加密後備份到 pCloud，包含配置、headless 授權、排程與驗證建議。","tags":["rclone","pcloud","synology","backup","docker"],"title":"在 Synology NAS 上用 rclone + pCloud 建立加密雲端備份"},{"categories":[],"contents":"Tailscale 簡介 Tailscale 是一款基於 WireGuard 技術的點對點虛擬私人網路 (VPN) 解決方案。與傳統的 VPN 不同，Tailscale 的設計目的是簡化網路配置和安全性管理，無需繁瑣的防火牆設置或是專業的網路知識。它透過 Tailscale 提供的控制伺服器自動處理網路節點之間的連線協商，無需使用者具備 Public IP。Tailscale 支援多種作業系統和設備，包括 Linux、Windows、macOS、iOS、Android 等，並且可以輕鬆應對現代網路環境中的 NAT 穿透問題。\n有關 Tailscale 運作原理的介紹，可以參考官方的說明\n為何選擇 Tailscale 由於我目前的網路環境，我的 openwrt 拿到的 WAN IP 是第四台的 private IP，然後再透過他們的 NAT 出去，無法直接拿到一個 public IP 連接到 Internet，因此如果使用 DDNS + Wireguard 的解決方案的話還需要請第四台廠商幫我開 port forwarding。因為我不希望更改租屋處的網路設定，因此選擇了 Tailscale 作為解決方案。Tailscale 的好處在於它可以透過其伺服器自動協商並建立 VPN 網域，不需要準備一個 Public IP。\n在 OpenWrt 上安裝 Tailscale 在 OpenWrt 的官方 wiki 上有一篇教學文章，是使用 opkg 上面已經打包好的 package 安裝 Tailscale, 但我抓下來發現 opkg 上提供的 tailscale 版本為 1.32，而我安裝的當下 tailscale 已經出到 1.74 版了，且官方有警告 1.32 版本存在安全性問題，因此我後來決定不透過 opkg 安裝 Tailscale\n如果你也跟我一樣先前已經透過 opkg 安裝舊版本的 tailscale 了，則可以透過 opkg remove tailscale 先將舊版 tailscale 移除 移除後系統仍會殘留兩個 binary: /usr/bin/tailscale 以及 /usr/sbin/tailscaled，必須要將這兩個 binary 刪除或是稍候直接用從官網下載的 binary 覆蓋過去，這樣系統才不會殘留不同版本的 tailscale\n1. Install Tailscale from static binary 其實官方有提供一鍵安裝的 script，但似乎只支援他有列出的 Linux distro, 我在 OpenWrt 上 script 無法判別我的 OS, 因此我選擇直接下載官方打包的 static binary 自行安裝.\n從 這裡 可以下載到官方最新的 release，根據你的裝置的 CPU 架構選擇對應的 binary 即可，由於我的裝置是 Raspberry Pi 4, 因此要下載 arm64 版本；如果懶得自己下載也可以用 adyanth/openwrt-tailscale-enabler, 已經有人幫忙打包好需要的東西了，照著 readme 做就可以了\n從官方載點下載下來解壓縮後可以看到以下的檔案結構：\ntailscale_1.74.1_arm64 ├── systemd | ├── tailscaled.defaults | └── tailscaled.service ├── tailscale └── tailscaled 可以看到最核心的兩個執行檔 tailscale \u0026amp; tailscaled, 將 tailscale 放至 /usr/bin, tailscaled 放至 /usr/sbin 即可。 至於 systemd 資料夾裡面的 script, 因為 OpenWrt 本身並不支援 systemd，所以不可用\n接下來，啟動 tailscale daemon\n/etc/init.d/tailscale start 順便設定 init.d 讓 tailscale 在開機時自動啟動服務\n/etc/init.d/tailscale enable 2. Firewall setting on OpenWrt 將 OpenWrt 連上 Tailscale 之前，可以先將防火牆設定好，一樣參考 OpenWrt 的官方文件即可\na. 創建 tailscale 介面 登入 LuCI -\u0026gt; Network -\u0026gt; Interfaces → Add new interface，創建一個 tailscale 的 interface, 協定 (Protocol) 選擇 Unmanaged, 裝置 (Device) 選擇 tailscale0\n並且在 interface 的 firewall 設定中，創建並選擇 tailscale 這個 firewall zone b. 修改 init.d script 根據 OpenWrt 的官方教學說明，為了讓 Tailscale 正常運行，並為 tailscale0 介面分配 IP，需要修改 init.d 腳本。\n在腳本中加入以下這一行\nprocd_append_param command --tun tailscale0 這是因為若未添加此行，防火牆配置將無法生效，導致其他裝置無法成功訪問 OpenWrt 的 LAN。\n修改後的 init.d 腳本如下\n#!/bin/sh /etc/rc.common # Copyright 2020 Google LLC. # Copyright (C) 2021 CZ.NIC z.s.p.o. (https://www.nic.cz/) # SPDX-License-Identifier: Apache-2.0 USE_PROCD=1 START=80 start_service() { local state_file local port local std_err std_out config_load tailscale config_get_bool std_out \u0026#34;settings\u0026#34; log_stdout 1 config_get_bool std_err \u0026#34;settings\u0026#34; log_stderr 1 config_get port \u0026#34;settings\u0026#34; port 41641 config_get state_file \u0026#34;settings\u0026#34; state_file /etc/tailscale/tailscaled.state /usr/sbin/tailscaled --cleanup procd_open_instance procd_set_param command /usr/sbin/tailscaled # Set the port to listen on for incoming VPN packets. # Remote nodes will automatically be informed about the new port number, # but you might want to configure this in order to set external firewall # settings. procd_append_param command --port \u0026#34;$port\u0026#34; procd_append_param command --state \u0026#34;$state_file\u0026#34; # work around from https://openwrt.org/docs/guide-user/services/vpn/tailscale/start procd_append_param command --tun tailscale0 procd_set_param respawn procd_set_param stdout \u0026#34;$std_out\u0026#34; procd_set_param stderr \u0026#34;$std_err\u0026#34; procd_close_instance } stop_service() { /usr/sbin/tailscaled --cleanup } 改完記得將 daemon 重啟\n/etc/init.d/tailscale restart c. Firewall 設定 首先按照 Tailscale 的 Set up a subnet router Enable ip forwarding\n接著在 LuCI -\u0026gt; Network -\u0026gt; Firewall -\u0026gt; Zones -\u0026gt; Add, 按照以下設定防火牆\nName: tailscale\nInput: ACCEPT\nOutput: ACCEPT\nForward: ACCEPT\nMasquerading: on\nMSS Clamping: on\nCovered networks: tailscale\nAllow forward to destination zones: LAN + WAN (若有需要將 OpenWrt 設為 Exit node 才需要加入 WAN)\nAllow forward from source zones: LAN\n由於新建了一個 firewall zone, 因此如果原本有設定 port forwarding 的話，也要為 tailscale zone 加入對應的 port forwarding 規則，讓連上 tailscale network 的裝置可以透過原本的 LAN IP 存取內網服務 3. Connect to Tailscale 上述設定都完成後，就可以使用以下指令連上 Tailscale 了\ntailscale up --netfilter-mode=off --accept-dns=false --advertise-routes=10.10.0.0/24 --accept-routes --advertise-exit-node 參數說明：\n--netfilter-mode=off: 自己管理 firewall --accept-dns=false: 由於我的 OpenWrt 有使用 AdGuardHome 作為我的 DNS server，因此使用此參數避免 Tailscale 更改我的 OpenWrt 的 DNS 設定 --advertise-routes: 啟用 Tailscale 的 Subnet routes 功能，這樣連上我的 Tailscale network 的裝置都可以存取位於 OpenWrt 內的 LAN 裝置，可以透過這種方式來把我的 self-hosted 服務提供到 VPN 上 --accept-routes: 如果有其他裝置 expose 了他自己的 Subnet routes, 開啟此選項可以讓此裝置連上其他裝置的 Subnet routes --advertise-exit-node: 將我的 OpenWrt 作為一個網路出口節點，這樣如果人不在台灣就可以有一個跳板可以跳回台灣上網 完整的 tailscale up 參數說明可以參考 官方說明\n4. Tailscale admin console 設定 Raspberry Pi 成功連上 Tailscale 後，還需至 Tailscale 的 admin console 設定 Subnet routes \u0026amp; DNS\na. 啟用 Subnet routes \u0026amp; Exit Node 首先按照官方的 enable-subnet-routes-from-the-admin-console 和 allow-the-exit-node-from-the-admin-console 啟用 Subnet routes 以及 Exit node 功能\nb. DNS Configuration in Tailscale 去 Tailscale 的 Admin console 的 DNS 頁面，將自架的 DNS server 的 IP address 加入 Nameservers 設定，並打開 Override local DNS 選項，這樣就會強制讓連上 Tailscale network 的裝置都使用我自架的 DNS server\n如果沒將 Override local DNS 選項打開，Tailscale 預設是會使用該裝置自己的 DNS 設定，這樣就沒辦法使用到 AdGuardHome 的 DNS 去擋廣告了 這邊可以注意到由於前面已經有把 LAN 的網段透過 Subnet routes expose 給 Tailscale network 了，所以這邊可以直接將 DNS 的 server IP 直接設為 LAN IP，且 AdGuardHome 也不需要額外去 Listen tailscale0 interface 即可正常提供 DNS 服務。\nReference https://tailscale.com/ https://openwrt.org/docs/guide-user/services/vpn/tailscale/start https://github.com/adyanth/openwrt-tailscale-enabler AdGuard Home + Tailscale = Erase Ads on the Go ","date":"October 4, 2024","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/use-tailscale-adguardhome-to-build-vpn/","summary":"在 OpenWrt 上使用 Tailscale 架設個人私有網域","tags":["openwrt","raspberry-pi","vpn","homelab"],"title":"[OpenWrt] 使用 Tailscale + AdGuardHome 架設個人 VPN 網域"},{"categories":[],"contents":"前言 c++ 的 STL 有提供兩個跟 binary seach 有關的 function: lower_bound 和 upper_bound, 每次在寫 leetcode 相關的題目時都會一直忘記這兩個 function 的定義，故決定紀錄一下兩者的定義及用法\nInclude STL lower_bound 和 upper_bound 被定義在 \u0026lt;algorithm\u0026gt; 裡面\n#include \u0026lt;algorithm\u0026gt; Lower Bound 找出數列中第一個 大於或等於 target 的位置, 換句話說就是找到 \u0026gt;= target 的最小值的位置\n// vector\u0026lt;int\u0026gt; v; // assume v is a sorted array auto it = lower_bound(v.begin(), v.end(), target); int idx = it - v.begin(); Upper Bound 找出數列中第一個 大於 target 的位置, 換句話說就是找到 \u0026gt; target 的最小值的位置\n// vector\u0026lt;int\u0026gt; v; // assume v is a sorted array auto it = upper_bound(v.begin(), v.end(), target) - v.begin(); int idx = it - v.begin(); lower_bound 和 upper_bound 都會回傳 對應型態的 iterator, 如果傳入的 sequence 找不到目標值，就會回傳 v.end()\nCustom Compare function 有時候已排序的陣列可能是自訂的資料結構，這時候可以透過自定義的 compare function 來使用 lower_bound 和 upper_bound\n// define custom compare function bool my_compare(const my_struct_t \u0026amp;lhs, const my_struct_t \u0026amp;rhs) { // do something return result; } // example usage // vector\u0026lt;my_struct_t\u0026gt; v; // my_struct_t target; auto it = lower_bound(v.begin(), v.end(), target, my_compare); // auto it = upper_bound(v.begin(), v.end(), target, my_compare); ","date":"July 24, 2023","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/algorithm-note/binary-search/","summary":"前言 c++ 的 STL 有提供兩個跟 binary seach 有關的 function: lower_bound 和 upper_bound, 每次在寫 leetcode 相關的題目時都會一直忘記這兩個 function 的定義，故決定紀錄一下兩者的定義及用法\nInclude STL lower_bound 和 upper_bound 被定義在 \u0026lt;algorithm\u0026gt; 裡面\n#include \u0026lt;algorithm\u0026gt; Lower Bound 找出數列中第一個 大於或等於 target 的位置, 換句話說就是找到 \u0026gt;= target 的最小值的位置\n// vector\u0026lt;int\u0026gt; v; // assume v is a sorted array auto it = lower_bound(v.begin(), v.end(), target); int idx = it - v.begin(); Upper Bound 找出數列中第一個 大於 target 的位置, 換句話說就是找到 \u0026gt; target 的最小值的位置\n// vector\u0026lt;int\u0026gt; v; // assume v is a sorted array auto it = upper_bound(v.","tags":["algorithm","binary-search"],"title":"Binary Search 中的 lower bound \u0026 upper bound"},{"categories":[],"contents":"前言 最近在寫 side project 時想要設定 Github Actions 來自動化編譯跟測試流程，但是按照我之前的經驗是第一次設定 github action 的 workflow 時都會需要不斷修改來達到自己想要的結果，但是如果想要測試的話就會需要一直 commit \u0026amp; push 到 github 上面才有辦法測試，因此這次在設定 workflow 前，我想要找到一個可以不用 push 到 github 就可以在 local 端測試我的 workflow 的工具，這樣我就可以先測試完我的 workflow 後再一次 push 上去 github, 減少設定錯誤的機會，也不用一直繁瑣的 commit \u0026amp; push.\n而我找到的工具就是 nektos/act 這個專案，目前在 github 上約有 40k 個 stars，可見這個需求有多大，本篇文就是紀錄如何使用這個工具的筆記。\nInstall nektos/act 這個專案有提供多種平台以及安裝方式，因為基本上我只會用這個工具來測試我的 workflow 有沒有寫錯，因此我選擇的是安裝官方提供的 GitHub CLI 擴充套件\nInstall Github CLI Offical installation guide\n首先按照官方教學安裝 Github CLI\ntype -p curl \u0026gt;/dev/null || (sudo apt update \u0026amp;\u0026amp; sudo apt install curl -y) curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \\ \u0026amp;\u0026amp; sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \\ \u0026amp;\u0026amp; echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\u0026#34; | sudo tee /etc/apt/sources.list.d/github-cli.list \u0026gt; /dev/null \\ \u0026amp;\u0026amp; sudo apt update \\ \u0026amp;\u0026amp; sudo apt install gh -y 安裝完畢後，在終端機上打 gh 就可以使用 Github CLI 了\ngh --help Install nektos/act 首先，必須確認你的電腦已經安裝 docker, 因為這個工具會使用 docker 來建構它的執行環境、跑 workflow 若你的環境是 WSL2, 則可以直接安裝 Docker Desktop on Windows, 按照官方教學設定好後，在 WSL2 裡面應該就不用再特別設定就可以使用 docker 了\n接著就可以按照 nektos/act 的 readme 教學安裝 gh-act\ngh extension install https://github.com/nektos/gh-act 安裝完畢後，在終端機打 gh act 就可以使用 act 來測試我們自己撰寫的 workflow 了！\nRun 第一次使用 act 會需要設定一些東西，按照工具的引導後就可以測試 workflow 了\n直接執行 gh act，它會自動抓你的專案底下的 workflow 並觸發 on: push 事件，然後開始執行你的 workflow\ngh act 如果你的 workflow 中有需要用到 GITHUB_TOKEN 的話，act 也有參數可以直接帶入\ngh act -s GITHUB_TOKEN=\u0026#34;$(gh auth token)\u0026#34; 成功執行 workflow 的實際畫面如下，提供讀者參考 Reference nektos/act Github Actions GitHub CLI Docker Desktop on Windows ","date":"July 15, 2023","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/test-github-actions-locally/","summary":"前言 最近在寫 side project 時想要設定 Github Actions 來自動化編譯跟測試流程，但是按照我之前的經驗是第一次設定 github action 的 workflow 時都會需要不斷修改來達到自己想要的結果，但是如果想要測試的話就會需要一直 commit \u0026amp; push 到 github 上面才有辦法測試，因此這次在設定 workflow 前，我想要找到一個可以不用 push 到 github 就可以在 local 端測試我的 workflow 的工具，這樣我就可以先測試完我的 workflow 後再一次 push 上去 github, 減少設定錯誤的機會，也不用一直繁瑣的 commit \u0026amp; push.\n而我找到的工具就是 nektos/act 這個專案，目前在 github 上約有 40k 個 stars，可見這個需求有多大，本篇文就是紀錄如何使用這個工具的筆記。\nInstall nektos/act 這個專案有提供多種平台以及安裝方式，因為基本上我只會用這個工具來測試我的 workflow 有沒有寫錯，因此我選擇的是安裝官方提供的 GitHub CLI 擴充套件\nInstall Github CLI Offical installation guide\n首先按照官方教學安裝 Github CLI\ntype -p curl \u0026gt;/dev/null || (sudo apt update \u0026amp;\u0026amp; sudo apt install curl -y) curl -fsSL https://cli.","tags":["github","github-action"],"title":"如何在 Local 端測試/執行 Github Actions"},{"categories":[],"contents":"最近因為需要在 Synology NAS 上部署 Coder，container 需要 docker 的運行權限，因為 DSM 的 docker 比較特別，故這裡紀錄一下要如何讓非 root user 也能使用 docker\n步驟 首先 ssh 進 NAS 後，使用以下指令來新增 \u0026ldquo;docker\u0026rdquo; 這個 group, 並把需要 docker 權限的 user 加入 docker group\nsudo synogroup --add docker sudo synogroup --member docker $USER # 將自己加入 docker group 成功新增後，登入 DSM，可以看到在使用者群組的地方多了一個 docker, 可以加上補充說明這個 group 的作用 (所以理論上應該直接在 DSM 新增 group 就好了，但是我沒試過) 接著將 docker.sock 的 group ownership 從 root 改成 docker\nsudo chown root:docker /var/run/docker.sock 改完後重新登入，應該就可以不用加 sudo 就可以執行 docker command 了！\nReference Manage docker without needing sudo on your Synology NAS ","date":"June 21, 2023","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/run-docker-command-without-sudo-on-synology-nas/","summary":"最近因為需要在 Synology NAS 上部署 Coder，container 需要 docker 的運行權限，因為 DSM 的 docker 比較特別，故這裡紀錄一下要如何讓非 root user 也能使用 docker\n步驟 首先 ssh 進 NAS 後，使用以下指令來新增 \u0026ldquo;docker\u0026rdquo; 這個 group, 並把需要 docker 權限的 user 加入 docker group\nsudo synogroup --add docker sudo synogroup --member docker $USER # 將自己加入 docker group 成功新增後，登入 DSM，可以看到在使用者群組的地方多了一個 docker, 可以加上補充說明這個 group 的作用 (所以理論上應該直接在 DSM 新增 group 就好了，但是我沒試過) 接著將 docker.sock 的 group ownership 從 root 改成 docker\nsudo chown root:docker /var/run/docker.sock 改完後重新登入，應該就可以不用加 sudo 就可以執行 docker command 了！","tags":["synology","docker"],"title":"如何在 Synology NAS 使用 non-root user 執行 Docker command"},{"categories":[],"contents":"問題 我的 OpenWrt 是安裝在樹梅派上面，採用 squashfs, 安裝完後可以正常使用，但是可用空間只有 100 MB 左右，這是正常現象，如果沒有要安裝很多套件的話其實 100 MB 很夠用了，但是就無法完整利用到整個 SD 卡的空間 (我是裝 32G)；如果要裝 docker 等較大型的套件很快就空間不足了，故本篇文章即是要解決此問題。\n其實官方有 Wiki 教學是利用到 losetup 來完成，但是我自己嘗試是沒有成功的，我也懶得研究為甚麼，僅留下連結給有興趣的讀者自行嘗試看看。\n解決方式 首先安裝套件，我們需要 cfdisk 和 resize2fs\nopkg update opkg install cfdisk resize2fs 安裝好後，可以先用 ls /dev 確認你的 SD 卡的 device 名稱，通常應該會是 /dev/mmcblk0\n在 terminal 輸入以下指令\ncfdisk /dev/mmcblk0 接著你應該會進入 cfdisk 的互動式介面 可以看到在 /dev/mmcblk0p2 後面有很大的 free space.\n接下來，用鍵盤移到 /dev/mmcblk0p2，會出現 Resize 的選項，選擇 Resize 這時系統會要你輸入要劃多大的空間，這裡不用輸入，保留預設值就好，這樣系統就會把所有的 free space 都劃進 /dev/mmcblk0p2，結果如下 完成後輸入 yes 確認變更，這時候從畫面上可以看到 /dev/mmcblk0p2 已經變成 29.7 G 了！確認沒問題後選擇 Write 把此次變更寫入，Quit 離開 cfdisk\n接著重開機後，執行 resize2fs\nresize2fs /dev/loop0 若沒有錯誤訊息，就表示成功了，可以用 df -h 或是登入 luci 確認可用空間，以下提供 resize 前後的比較\nBefore After 可以看到 /dev/loop0 的可用空間變大了！收工。\nReference\nExpanding OpenWrt squashfs image (SDcard) [OpenWrt Wiki] SD card ","date":"November 28, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/openwrt-expand-squashfs/","summary":"問題 我的 OpenWrt 是安裝在樹梅派上面，採用 squashfs, 安裝完後可以正常使用，但是可用空間只有 100 MB 左右，這是正常現象，如果沒有要安裝很多套件的話其實 100 MB 很夠用了，但是就無法完整利用到整個 SD 卡的空間 (我是裝 32G)；如果要裝 docker 等較大型的套件很快就空間不足了，故本篇文章即是要解決此問題。\n其實官方有 Wiki 教學是利用到 losetup 來完成，但是我自己嘗試是沒有成功的，我也懶得研究為甚麼，僅留下連結給有興趣的讀者自行嘗試看看。\n解決方式 首先安裝套件，我們需要 cfdisk 和 resize2fs\nopkg update opkg install cfdisk resize2fs 安裝好後，可以先用 ls /dev 確認你的 SD 卡的 device 名稱，通常應該會是 /dev/mmcblk0\n在 terminal 輸入以下指令\ncfdisk /dev/mmcblk0 接著你應該會進入 cfdisk 的互動式介面 可以看到在 /dev/mmcblk0p2 後面有很大的 free space.\n接下來，用鍵盤移到 /dev/mmcblk0p2，會出現 Resize 的選項，選擇 Resize 這時系統會要你輸入要劃多大的空間，這裡不用輸入，保留預設值就好，這樣系統就會把所有的 free space 都劃進 /dev/mmcblk0p2，結果如下 完成後輸入 yes 確認變更，這時候從畫面上可以看到 /dev/mmcblk0p2 已經變成 29.","tags":["openwrt","raspberry-pi"],"title":"[OpenWrt] 如何擴充 squashfs 的可用空間"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Unique Paths\n題目大綱 給你一個 m x n 的矩陣地圖, 請你找出從座標 (0, 0) 走到 (m-1, n-1) 一共有多少種走法。題目有限制每一次只能往下或往右走一步。\n解題思路 解法一 - DP 設計一個 2 維陣列 dp[m][n], 其中 dp[i][j] 對應到座標 (i, j)，代表了從 (0, 0) 走到 (i, j) 一共有多少種走法。\n接著從題目的限制我們可以知道，要走到 (i, j) 的話一定要先走到 (i-1, j) 或是 (i, j-1)，然後再往下或往右走一步來到達 (i, j)。\n也就是說，走到 (i, j) 的走法數，會等於走到 (i-1, j) 的走法數加上走到 (i, j-1) 的走法數\n有了這層關係，我們就可以得出 dp 的公式如下：\ndp[i][j] = dp[i - 1][j] + dp[i][j - 1] 而一開始要初始化 dp[i][0] = 1 (0 \u0026lt;= i \u0026lt;= m) 以及 dp[0][j] = 1 (0 \u0026lt;= j \u0026lt;= n)，代表從起點開始，一路往右或往下都只有一種走法\n解法二 - 數學解 由題目可知，一個 m x n 的地圖從 (0, 0) 要走到終點 (m-1, n-1)，不論過程怎麼走，總共都需要往下走 m-1 步及往右走 n-1 步。而這就是經典的高中排列組合的題目，故我們只需要算出 m-1 個下 ( ↓ ) 跟 n-1 個右 ( → ) 一共有多少種組合即可求出答案。\n因此答案就會是組合 C((m-1) + (n-1), n-1)\n例如範例測資 m = 3, n = 7，則答案就是 C(10, 7) (C 10 取 7) = 28\n程式碼 解法一 class Solution { public: int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); dp[0][0] = 1; for (int i = 0; i \u0026lt; m; i++) dp[i][0] = 1; for (int i = 0; i \u0026lt; n; i++) dp[0][i] = 1; for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } }; 解法二 這邊因為我發現如果直接將階層算完最後再除的話會遇到 overflow 的問題，故這邊我的寫法是先除掉一個階層的分母，然後邊算邊除來減小數字，所以程式看起來會比較 tricky 一點\nclass Solution { public: int comb(int n, int k) { int k2 = n - k; int a = 1; int b = 1; int i = n, j = 2; while ((i \u0026gt; k) \u0026amp;\u0026amp; (j \u0026lt;= k2)) { a *= i; b *= j; if (a % b == 0) { a /= b; b = 1; } i--; j++; } for (; i \u0026gt; k; i--) { a *= i; } for (; j \u0026lt;= k2; j++) { b *= j; } return a / b; } int uniquePaths(int m, int n) { m--; n--; return comb(m+n, m \u0026gt; n ? m : n); } }; ","date":"November 1, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-62/","summary":"題目難度：Medium\n題目連結: Unique Paths\n題目大綱 給你一個 m x n 的矩陣地圖, 請你找出從座標 (0, 0) 走到 (m-1, n-1) 一共有多少種走法。題目有限制每一次只能往下或往右走一步。\n解題思路 解法一 - DP 設計一個 2 維陣列 dp[m][n], 其中 dp[i][j] 對應到座標 (i, j)，代表了從 (0, 0) 走到 (i, j) 一共有多少種走法。\n接著從題目的限制我們可以知道，要走到 (i, j) 的話一定要先走到 (i-1, j) 或是 (i, j-1)，然後再往下或往右走一步來到達 (i, j)。\n也就是說，走到 (i, j) 的走法數，會等於走到 (i-1, j) 的走法數加上走到 (i, j-1) 的走法數\n有了這層關係，我們就可以得出 dp 的公式如下：\ndp[i][j] = dp[i - 1][j] + dp[i][j - 1] 而一開始要初始化 dp[i][0] = 1 (0 \u0026lt;= i \u0026lt;= m) 以及 dp[0][j] = 1 (0 \u0026lt;= j \u0026lt;= n)，代表從起點開始，一路往右或往下都只有一種走法","tags":["leetcode","dynamic-programming","combinatorics"],"title":"Leetcode 隨筆 - 62. Unique Paths"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Word Break\n題目大綱 給定一個字串 s 和一個字串陣列 wordDict, 請你判斷是否有辦法\n程式碼 解法一 這是我看完 NeetCode 影片的前半段的解題思路後想出來的解法\nclass Solution { private: vector\u0026lt;int\u0026gt; word_len; int s_len; vector\u0026lt;int\u0026gt; dp; public: void solve(string\u0026amp; s, int idx, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { if (idx \u0026gt;= s_len) { dp[s_len] = 1; return; } if (dp[idx] != -1) return; for (int i = 0; i \u0026lt; wordDict.size(); i++) { if (s.compare(idx, word_len[i], wordDict[i]) == 0) { solve(s, idx + word_len[i], wordDict); if (dp[s_len] == 1) return; } } dp[idx] = 0; } bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { word_len.resize(wordDict.size(), 0); s_len = s.length(); dp.resize(s_len + 1, -1); dp[s_len] = 0; for (int i = 0; i \u0026lt; wordDict.size(); i++) { word_len[i] = wordDict[i].length(); } solve(s, 0, wordDict); return dp[s_len]; } }; 解法二 NeetCode 提出的最佳解\nclass Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { vector\u0026lt;bool\u0026gt; dp(s.length() + 1, false); dp[s.length()] = true; for (int i = s.length() - 1; i \u0026gt;= 0; i--) { for (string word : wordDict) { if (s.compare(i, word.length(), word) == 0) { dp[i] = dp[i + word.length()]; } if (dp[i]) break; } } return dp[0]; } }; ","date":"October 30, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-139/","summary":"題目難度：Medium\n題目連結: Word Break\n題目大綱 給定一個字串 s 和一個字串陣列 wordDict, 請你判斷是否有辦法\n程式碼 解法一 這是我看完 NeetCode 影片的前半段的解題思路後想出來的解法\nclass Solution { private: vector\u0026lt;int\u0026gt; word_len; int s_len; vector\u0026lt;int\u0026gt; dp; public: void solve(string\u0026amp; s, int idx, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { if (idx \u0026gt;= s_len) { dp[s_len] = 1; return; } if (dp[idx] != -1) return; for (int i = 0; i \u0026lt; wordDict.size(); i++) { if (s.compare(idx, word_len[i], wordDict[i]) == 0) { solve(s, idx + word_len[i], wordDict); if (dp[s_len] == 1) return; } } dp[idx] = 0; } bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { word_len.","tags":["leetcode","string","dynamic-programming"],"title":"Leetcode 隨筆 - 139. Word Break"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Maximum Product Subarray\n題目大綱 給你一個整數陣列, 找出擁有最大乘積的子陣列 (contiguous non-empty subarray)\n程式碼 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = nums[0]; int max_product = 1; int min_product = 1; int t1, t2; for (int i = 0; i \u0026lt; nums.size(); i++) { t1 = max_product * nums[i]; t2 = min_product * nums[i]; max_product = max(t1, max(t2, nums[i])); min_product = min(t1, min(t2, nums[i])); ans = max(max_product, ans); } return ans; } }; ","date":"October 29, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-152/","summary":"題目難度：Medium\n題目連結: Maximum Product Subarray\n題目大綱 給你一個整數陣列, 找出擁有最大乘積的子陣列 (contiguous non-empty subarray)\n程式碼 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = nums[0]; int max_product = 1; int min_product = 1; int t1, t2; for (int i = 0; i \u0026lt; nums.size(); i++) { t1 = max_product * nums[i]; t2 = min_product * nums[i]; max_product = max(t1, max(t2, nums[i])); min_product = min(t1, min(t2, nums[i])); ans = max(max_product, ans); } return ans; } }; ","tags":["leetcode","array","dynamic-programming"],"title":"Leetcode 隨筆 - 152. Maximum Product Subarray"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Binary Tree Right Side View\n題目大綱 給你一個 binary tree, 請你找出：從右邊看這棵樹，能看到的 node 有哪些。\n解題思路 這題翻譯過後就是，請你找出此 binary tree 的每一層的最右邊的 node，所以我們只需要使用 level order traverse 的方式把 tree 掃過一遍抓出每層最右邊的 node 就行了！\n程式碼 實作採用 C++ STL 的 queue, 遍歷時加上每個 node 的 level 資訊，當每掃到新的 level 時就會把該 node 加進 ans 裡面並更新 level 資訊；再來因為我們需要最右邊的 node, 所以 traverse 順序改成先掃右邊的 subtree 再掃左邊 subtree 的方式比較方便實作。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; rightSideView(TreeNode* root) { queue\u0026lt;pair\u0026lt;TreeNode*, int\u0026gt;\u0026gt; q; pair\u0026lt;TreeNode*, int\u0026gt; node; vector\u0026lt;int\u0026gt; ans; int cur_level = -1; if (root == NULL) return vector\u0026lt;int\u0026gt;(); q.push(pair\u0026lt;TreeNode*, int\u0026gt;(root, 0)); while (!q.empty()) { node = q.front(); q.pop(); if (node.second != cur_level) { ans.push_back(node.first-\u0026gt;val); cur_level = node.second; } if (node.first-\u0026gt;right != NULL) { q.push(pair\u0026lt;TreeNode*, int\u0026gt;(node.first-\u0026gt;right, node.second + 1)); } if (node.first-\u0026gt;left != NULL) { q.push(pair\u0026lt;TreeNode*, int\u0026gt;(node.first-\u0026gt;left, node.second + 1)); } } return ans; } }; ","date":"July 11, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-199/","summary":"題目難度：Medium\n題目連結: Binary Tree Right Side View\n題目大綱 給你一個 binary tree, 請你找出：從右邊看這棵樹，能看到的 node 有哪些。\n解題思路 這題翻譯過後就是，請你找出此 binary tree 的每一層的最右邊的 node，所以我們只需要使用 level order traverse 的方式把 tree 掃過一遍抓出每層最右邊的 node 就行了！\n程式碼 實作採用 C++ STL 的 queue, 遍歷時加上每個 node 的 level 資訊，當每掃到新的 level 時就會把該 node 加進 ans 裡面並更新 level 資訊；再來因為我們需要最右邊的 node, 所以 traverse 順序改成先掃右邊的 subtree 再掃左邊 subtree 的方式比較方便實作。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; rightSideView(TreeNode* root) { queue\u0026lt;pair\u0026lt;TreeNode*, int\u0026gt;\u0026gt; q; pair\u0026lt;TreeNode*, int\u0026gt; node; vector\u0026lt;int\u0026gt; ans; int cur_level = -1; if (root == NULL) return vector\u0026lt;int\u0026gt;(); q.","tags":["leetcode","array"],"title":"Leetcode 隨筆 - 199. Binary Tree Right Side View"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Non-decreasing Array\n題目大綱 給你一個陣列 nums，請你檢查是否可以在 \u0026ldquo;最多修改一個元素的值\u0026rdquo; 的限制下，把這個陣列變成一個非遞減陣列 (原來就已經是非遞減陣列也可以算通過檢查)\n非遞減定義： nums[i] \u0026lt;= nums[i+1], where 0 \u0026lt;= i \u0026lt;= nums.size()-2\n解題思路 首先需要把陣列從頭開始掃描一遍，遇到 nums[i+1] \u0026lt; nums[i] 時停下來檢查是否可以修改元素值來完成題目要求，如果可以改，那就紀錄本次修改。所以我們可以用一個 counter 來記錄修改次數，而若修改次數大於 1 次就可以提前結束不用再往後檢查了。\n接下來重點就是：要怎麼確認可以修改(改成非遞減)？ 這裡可以分成幾個 case 來討論：\nCase 1. 陣列的開頭 or 結尾發生遞減情況 也就是 nums[0] \u0026gt; nums[1] or nums[nums.size()-1] \u0026gt; nums[nums.size()-2]，這時候一定可以修改，因為只要把陣列頭的值往下修或把陣列尾的值往上調就可以了，所以直接更新 counter (counter++) 即可。\nCase 2. 陣列中間發生遞減情況 這時候發生了 nums[i+1] \u0026lt; nums[i]，為了判斷是否能夠只改一個值就能改成非遞減陣列，我們必須額外再抓出 nums[i-1] \u0026amp; nums[i+2] 這兩個元素來幫助我們判斷。\n首先第一項檢查\nnums[i+2] 是否大於等於 nums[i-1] ?\n因為若這個條件不符合，代表除了 nums[i] 跟 nums[i+1] 之外，在 nums[i+2] 這個位置又讓陣列發生了遞減情況，所以至少要改兩個地方，這樣絕對達不到題目要求，因此我們可以提早結束判斷、回傳失敗結果。\n通過第一項檢查後，第二件我們要確認的是\nnums[i] 跟 nums[i+1] 的值是否至少有一個落在 [nums[i-1], nums[i+2]] 這個區間？\n若這個條件不符合，代表 nums[i] \u0026amp; nums[i+1] 都一定要被修改 (至少需要把它們兩個都放進這個區間內) 才可能達到非遞減，這樣就不符合題目要求了！\n若通過檢查，代表我們只要把 nums[i] 的值往下調整，或是把 nums[i+1] 的值往上調整，就可以達到非遞減 (最簡單的情形就是 nums[i] == nums[i+1])，只要選擇修改一個元素即可。因此，通過檢查後，我們可以更新 counter，然後繼續往後檢查陣列。\n最後，掃完陣列，我們就可以透過判斷counter 是否小於 2 來確認是否能完成題目要求，當然，若在過程中發現 counter 已經等於 2 了那我們就可以提前回傳結果。\n程式碼 在實作上，因為 counter \u0026gt;= 2 時就代表檢查失敗，所以在檢查過程中若發現失敗情形就可以直接把 counter 改成 2 讓迴圈提早結束。\nclass Solution { public: bool inline inRange(int n, int low, int high) { return (low \u0026lt;= n \u0026amp;\u0026amp; n \u0026lt;= high); } bool checkPossibility(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int modified_cnt = 0; int len = nums.size(); for(int i = 0; i \u0026lt; (len-1) \u0026amp;\u0026amp; (modified_cnt \u0026lt; 2); i++) { if (nums[i+1] \u0026lt; nums[i]) { // first or last element -\u0026gt; can modify if ((i == 0) || (i+1 == len-1)) { modified_cnt++; } else { if ((nums[i+2] - nums[i-1]) \u0026lt; 0) { modified_cnt = 2; // impossible to modify one element break; } if (!inRange(nums[i], nums[i-1], nums[i+2]) \u0026amp;\u0026amp; !inRange(nums[i+1], nums[i-1], nums[i+2])) { modified_cnt = 2; break; } else { modified_cnt++; } } } } return modified_cnt \u0026lt; 2; } }; ","date":"June 25, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-665/","summary":"題目難度：Medium\n題目連結: Non-decreasing Array\n題目大綱 給你一個陣列 nums，請你檢查是否可以在 \u0026ldquo;最多修改一個元素的值\u0026rdquo; 的限制下，把這個陣列變成一個非遞減陣列 (原來就已經是非遞減陣列也可以算通過檢查)\n非遞減定義： nums[i] \u0026lt;= nums[i+1], where 0 \u0026lt;= i \u0026lt;= nums.size()-2\n解題思路 首先需要把陣列從頭開始掃描一遍，遇到 nums[i+1] \u0026lt; nums[i] 時停下來檢查是否可以修改元素值來完成題目要求，如果可以改，那就紀錄本次修改。所以我們可以用一個 counter 來記錄修改次數，而若修改次數大於 1 次就可以提前結束不用再往後檢查了。\n接下來重點就是：要怎麼確認可以修改(改成非遞減)？ 這裡可以分成幾個 case 來討論：\nCase 1. 陣列的開頭 or 結尾發生遞減情況 也就是 nums[0] \u0026gt; nums[1] or nums[nums.size()-1] \u0026gt; nums[nums.size()-2]，這時候一定可以修改，因為只要把陣列頭的值往下修或把陣列尾的值往上調就可以了，所以直接更新 counter (counter++) 即可。\nCase 2. 陣列中間發生遞減情況 這時候發生了 nums[i+1] \u0026lt; nums[i]，為了判斷是否能夠只改一個值就能改成非遞減陣列，我們必須額外再抓出 nums[i-1] \u0026amp; nums[i+2] 這兩個元素來幫助我們判斷。\n首先第一項檢查\nnums[i+2] 是否大於等於 nums[i-1] ?\n因為若這個條件不符合，代表除了 nums[i] 跟 nums[i+1] 之外，在 nums[i+2] 這個位置又讓陣列發生了遞減情況，所以至少要改兩個地方，這樣絕對達不到題目要求，因此我們可以提早結束判斷、回傳失敗結果。","tags":["leetcode","array"],"title":"Leetcode 隨筆 - 665. Non-decreasing Array"},{"categories":[],"contents":"題目難度：Medium\n題目連結: Search a 2D Matrix\n題目大綱 給你一個 m x n 的整數二維陣列和一個 value target，要你判斷 target 是否在這個陣列中。 題目保證這個二維陣列：\n每個 row 的數字的順序已經由小到大排序過了 每個 row 的第一個數字一定比上一個 row 的最後一個數字還要大 解題思路 由題目可知，將這個二維陣列按照 row 展開成一維陣列後就是一個排序過的 array，所以我們就可以直接用 二分搜 (Binary Search) 來找 target。 需要注意的是傳入的是二維陣列，所以在寫 binary search 的時候需要轉換一維 \u0026amp; 二維之間的坐標系\n一維 \u0026amp; 二維坐標系轉換範例： 假設我們要轉換一維陣列的 index i 到一個 m x n (m rows * n columns) 的二維陣列的 index (row, col)\nrow = i / n; col = i % n; 程式碼 binary search 可以使用迴圈或遞迴的方式來實作，以下提供兩種版本供讀者參考\n迴圈版 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0, right = m*n - 1; int i, j, mid; while (left \u0026lt;= right) { mid = (left + right) / 2; i = mid / n; j = mid % n; if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u0026gt; target) { right = mid - 1; } else { left = mid + 1; } } return false; } }; 遞迴版 class Solution { public: int m, n; bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { m = matrix.size(); n = matrix[0].size(); return binarySearch(matrix, target, 0, m*n - 1); } bool binarySearch(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target, int begin, int end) { int mid; int i, j; if (begin \u0026gt; end) return false; mid = (begin + end) / 2; i = mid / n; j = mid % n; if (matrix[i][j] == target) { return true; } else if (matrix[i][j] \u0026gt; target) { return binarySearch(matrix, target, begin, mid-1); } else { return binarySearch(matrix, target, mid+1, end); } } }; ","date":"June 18, 2022","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-74/","summary":"題目難度：Medium\n題目連結: Search a 2D Matrix\n題目大綱 給你一個 m x n 的整數二維陣列和一個 value target，要你判斷 target 是否在這個陣列中。 題目保證這個二維陣列：\n每個 row 的數字的順序已經由小到大排序過了 每個 row 的第一個數字一定比上一個 row 的最後一個數字還要大 解題思路 由題目可知，將這個二維陣列按照 row 展開成一維陣列後就是一個排序過的 array，所以我們就可以直接用 二分搜 (Binary Search) 來找 target。 需要注意的是傳入的是二維陣列，所以在寫 binary search 的時候需要轉換一維 \u0026amp; 二維之間的坐標系\n一維 \u0026amp; 二維坐標系轉換範例： 假設我們要轉換一維陣列的 index i 到一個 m x n (m rows * n columns) 的二維陣列的 index (row, col)\nrow = i / n; col = i % n; 程式碼 binary search 可以使用迴圈或遞迴的方式來實作，以下提供兩種版本供讀者參考","tags":["leetcode","array","binary-search"],"title":"LeetCode 隨筆 - 74. Search a 2D Matrix"},{"categories":[],"contents":"題目難度：Easy\n題目大綱 給你一個單向的 linked list, 再給你一個數字 val, 移除該 linked list 中所有 Node.val == val 的 node 並回傳處理完後的 linked list.\n解題思路 分兩步驟來解：\n首先檢查 head node 是否符合條件，若 head 符合條件則一直執行 head = head-\u0026gt;next ，不斷地把 head 截掉直到 head 是有效的 (Node.val != val) 接著一個 node 一個 node 去歷遍整個 list, 每個 node 的操作為：看下一個 node (後續以 next node 代稱) 是否符合條件，若符合的話就把自己的 next 指標接到 next node 的 next 指標 (也就是移除該 next node)，並繼續比較新的 next node (也就是回到第 2 步剛開始的操作)，否則繼續往下 loop 剩餘的 node 理論上移除掉的 node 要記得 free 掉不然會 memory leak, 不過這只是練習而已 LeetCode 好像也沒檢查這個，有沒有 free 掉都可以 AC\n程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* removeElements(struct ListNode* head, int val){ struct ListNode* dhead = head; struct ListNode* tmp = NULL; while (dhead != NULL \u0026amp;\u0026amp; dhead-\u0026gt;val == val) { dhead = dhead-\u0026gt;next; } for (struct ListNode* ptr = dhead; ptr != NULL \u0026amp;\u0026amp; ptr-\u0026gt;next != NULL;) { if (ptr-\u0026gt;next-\u0026gt;val == val) { tmp = ptr-\u0026gt;next; ptr-\u0026gt;next = ptr-\u0026gt;next-\u0026gt;next; free(tmp); } else { ptr = ptr-\u0026gt;next; } } return dhead; } ","date":"September 19, 2021","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/leetcode/leetcode-203/","summary":"題目難度：Easy\n題目大綱 給你一個單向的 linked list, 再給你一個數字 val, 移除該 linked list 中所有 Node.val == val 的 node 並回傳處理完後的 linked list.\n解題思路 分兩步驟來解：\n首先檢查 head node 是否符合條件，若 head 符合條件則一直執行 head = head-\u0026gt;next ，不斷地把 head 截掉直到 head 是有效的 (Node.val != val) 接著一個 node 一個 node 去歷遍整個 list, 每個 node 的操作為：看下一個 node (後續以 next node 代稱) 是否符合條件，若符合的話就把自己的 next 指標接到 next node 的 next 指標 (也就是移除該 next node)，並繼續比較新的 next node (也就是回到第 2 步剛開始的操作)，否則繼續往下 loop 剩餘的 node 理論上移除掉的 node 要記得 free 掉不然會 memory leak, 不過這只是練習而已 LeetCode 好像也沒檢查這個，有沒有 free 掉都可以 AC","tags":["leetcode"],"title":"LeetCode 隨筆 - 203. Remove Linked List Elements"},{"categories":[],"contents":"最近因為想要從 serial port 登入樹梅派而入手了一個 USB 轉 TTL 傳輸線，沒想到設定過程踩了不少雷，故寫了這篇作為提醒用。\n我是從電子材料行買的，型號為CONCBLUSBTTL，使用 PL2303TA 晶片\n理論上 win10 可以自動抓可以用的驅動，不需要特別下載。但如果有問題的話還是可以從晶片製造商的驅動程式下載頁面下載最新的驅動。解壓縮後除了驅動程式外還有一個小程式可以用來檢查晶片型號。\n這裡遇到我採的第一個雷 (自己雷)：在我一開始無法順利設定時，經爬文得知，由於舊款晶片 (PL2303HX 系列) 有偽造情形，故 win10 自動抓的驅動並不支援該款晶片的產品，需要下載舊版驅動才行，我還以為自己真幸運在 2021 還買得到舊款晶片，大費周章跑去前人的 blog 載舊版驅動，結果還是不行；又因為在舊版驅動下跑上面原廠提供的晶片型號檢查程式會將我的傳輸線誤判為 PL2303XA/PL2303HXA\n害我誤以為自己真的買到 PL2303HX 晶片，一直往錯誤的方向 google。後來完全解決不了，改用新版驅動再測最後一次，想說不行就要放棄這條線了，才發現原來都是驅動搞的鬼。\n這裡提醒一下接線的注意事項，傳輸線和樹梅派的 TX/RX 要反著接，也就是 線的 TX 要接到 Pi 的 RX，線的 RX 要接到 Pi 的 TX。GND 當然也要記得接。我這條線還有一個 5V 線，接上去後可以為 Pi 供電並開機，不過看其他人文章表示不一定要接這條線，而且我怕 GPIO 的供電不穩 (我用的是 pi 4, pi 4 在供電不足的情況下 wifi 會無法連線，就算能順利連上品質也不好，所以供電一定要足) 所以就沒接了。\n解決完驅動問題接下來就剩連線設定了，這裡是第二個要注意的地方，所有參數都要設定正確不然就會連不上！像是 speed，網路上的教學大都多是教人設定為 115200，但我的這條線，在裝置管理員的預設值為 9600，所以連線時要設 9600；還有 flow control 不論是 putty 或是 MobaXterm 預設都會是 Xon/Xoff，同樣與這條線的預設值不符，要記得關掉。\n下圖為不更改 CONCBLUSBTTL 這條線的預設值的情況下，我的 MobaXterm 的連線設定\n關於 CONCBLUSBTTL 的連線預設值可以去 裝置管理員 -\u0026gt; 連接埠設定找到\n所有設定都完成後就可以透過 serial port 連上 Pi 了！\nP.S. 建議連線設定完後要重插傳輸線並將 Pi 重開機比較不會遇到奇怪的問題，如果還是沒顯示 login 提示的話，可以試試看按 enter (我猜可能是要按 enter 才會觸發 pi 或是 傳輸線傳輸資料)\n","date":"February 10, 2021","hero":"/posts/raspberry-serial-port-login/featured.jpg","permalink":"https://jay16213.github.io/posts/raspberry-serial-port-login/","summary":"最近因為想要從 serial port 登入樹梅派而入手了一個 USB 轉 TTL 傳輸線，沒想到設定過程踩了不少雷，故寫了這篇作為提醒用。\n我是從電子材料行買的，型號為CONCBLUSBTTL，使用 PL2303TA 晶片\n理論上 win10 可以自動抓可以用的驅動，不需要特別下載。但如果有問題的話還是可以從晶片製造商的驅動程式下載頁面下載最新的驅動。解壓縮後除了驅動程式外還有一個小程式可以用來檢查晶片型號。\n這裡遇到我採的第一個雷 (自己雷)：在我一開始無法順利設定時，經爬文得知，由於舊款晶片 (PL2303HX 系列) 有偽造情形，故 win10 自動抓的驅動並不支援該款晶片的產品，需要下載舊版驅動才行，我還以為自己真幸運在 2021 還買得到舊款晶片，大費周章跑去前人的 blog 載舊版驅動，結果還是不行；又因為在舊版驅動下跑上面原廠提供的晶片型號檢查程式會將我的傳輸線誤判為 PL2303XA/PL2303HXA\n害我誤以為自己真的買到 PL2303HX 晶片，一直往錯誤的方向 google。後來完全解決不了，改用新版驅動再測最後一次，想說不行就要放棄這條線了，才發現原來都是驅動搞的鬼。\n這裡提醒一下接線的注意事項，傳輸線和樹梅派的 TX/RX 要反著接，也就是 線的 TX 要接到 Pi 的 RX，線的 RX 要接到 Pi 的 TX。GND 當然也要記得接。我這條線還有一個 5V 線，接上去後可以為 Pi 供電並開機，不過看其他人文章表示不一定要接這條線，而且我怕 GPIO 的供電不穩 (我用的是 pi 4, pi 4 在供電不足的情況下 wifi 會無法連線，就算能順利連上品質也不好，所以供電一定要足) 所以就沒接了。\n解決完驅動問題接下來就剩連線設定了，這裡是第二個要注意的地方，所有參數都要設定正確不然就會連不上！像是 speed，網路上的教學大都多是教人設定為 115200，但我的這條線，在裝置管理員的預設值為 9600，所以連線時要設 9600；還有 flow control 不論是 putty 或是 MobaXterm 預設都會是 Xon/Xoff，同樣與這條線的預設值不符，要記得關掉。","tags":["raspberry-pi","raspberry-pi-4","linux"],"title":"Raspberry Pi 透過 Serial Port 連線 - 踩雷筆記"},{"categories":[],"contents":"簡介 OpenCV 是由 intel 主導的一個電腦視覺的跨平台 library，可以用在許多應用上。yolo real-time detection ( 關於 yolo 的安裝與使用可以看我之前寫的文章: Yolo on Raspberry Pi 3 ) 就有用到 OpenCV。這篇文章就是要教如何在樹梅派上自行編譯、安裝 OpenCV 函式庫。雖然是強調在樹梅派上安裝 OpenCV，不過都是流程都是按照官方文件的 Linux 平台安裝教學走，所以只要是 Linux 平台都可以理論上都可以照著本篇文章來安裝 OpenCV！（當然裡面有些指令可能會不太一樣，例如 apt-get 是 debian 流派，如果是 redhat 就要換成 yum）\n要提醒的是 OpenCV 還有很多安裝的參數可以調整（例如對更多 Python / Java 的支援等）但是這篇文章目的是基本的 OpenCV 安裝，所以會略過那些非必要的步驟，需要更多自訂設定的人可以點上面的官方教學自行研究。\n安裝教學 首先安裝套件 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # 這行的套件非必要，可裝可不裝 從 Github 上把原始碼 clone 下來，並進入 opencv 資料夾 cd ~/ # 可自行選擇 clone 的位置 git clone https://github.com/opencv/opencv.git cd ~/opencv 整個 repo 有快 500 MB，clone 需要花一點時間\n切換 OpenCV 版本 非常重要！如果你有要用在 yolo 上面，或是你有其他用 C 編譯的套件是需要 OpenCV 的，請記得 checkout 到 3.4.0 版或以下，因為 3.4.1 版的 opencv 有 bug（不過根據開發者的說法是 OpenCV 3.X 不再支援 C compilation mode，所以嚴格來講不算是 bug，相關討論可以看 opencv-issue#10963，如果你堅持要用 3.4.1，裡面也有教你如何修正）如果沒有要用到 C compiler 的可以略過這步。\n先用 git tag -l 確認有哪些版本可供使用，接著就可以 checkout 過去了，例如我現在要示範的 3.4.0\ngit checkout 3.4.0 建立一個 build 資料夾並進入 mkdir build cd build/ 執行 cmake 產生 makefile cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 編譯函式庫 由於樹梅派只有 4 核，所以我們開 4 個核心編譯即可 make -j4 這裡是最困難的一步！因為我們都知道樹梅派的處理器效能沒有一般電腦那麼好，所以這裡會花很多時間，我自己的經驗是 -j4 開下去最快也要 90 ～ 120 分鐘（時間也會受到 SD 卡的讀寫速度影響，所以實際時間因人而異），而且樹梅派有可能編到一半當掉，所以一定要有耐心！如果一直當掉的話可以考慮降低核心數，但是相對的就會花更多時間。\n安裝函式庫 到了這步基本上就算成功了！接下來只須執行安裝指令： sudo make install 確認 OpenCV 有無安裝成功 重開樹梅派後，執行 python 進到 python 的 interpreter，測試看看是否可以正確的 import OpenCV 的函式庫及印出版本資訊，有印出版本就代表安裝成功。\n\u0026gt;\u0026gt;\u0026gt; import cv2 \u0026gt;\u0026gt;\u0026gt; cv2.__version__ 3.4.0 ","date":"April 2, 2018","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/opencv-on-raspberry/","summary":"簡介 OpenCV 是由 intel 主導的一個電腦視覺的跨平台 library，可以用在許多應用上。yolo real-time detection ( 關於 yolo 的安裝與使用可以看我之前寫的文章: Yolo on Raspberry Pi 3 ) 就有用到 OpenCV。這篇文章就是要教如何在樹梅派上自行編譯、安裝 OpenCV 函式庫。雖然是強調在樹梅派上安裝 OpenCV，不過都是流程都是按照官方文件的 Linux 平台安裝教學走，所以只要是 Linux 平台都可以理論上都可以照著本篇文章來安裝 OpenCV！（當然裡面有些指令可能會不太一樣，例如 apt-get 是 debian 流派，如果是 redhat 就要換成 yum）\n要提醒的是 OpenCV 還有很多安裝的參數可以調整（例如對更多 Python / Java 的支援等）但是這篇文章目的是基本的 OpenCV 安裝，所以會略過那些非必要的步驟，需要更多自訂設定的人可以點上面的官方教學自行研究。\n安裝教學 首先安裝套件 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # 這行的套件非必要，可裝可不裝 從 Github 上把原始碼 clone 下來，並進入 opencv 資料夾 cd ~/ # 可自行選擇 clone 的位置 git clone https://github.","tags":["linux","opencv","raspberry-pi-3"],"title":"OpenCV on Raspberry Pi 3"},{"categories":[],"contents":"簡介 Yolo 是一開放原始碼的影像辨識工具，可以進行圖片、影片、即時影像辨識。因為我的專題需要一個偵測人物走進一個空間的功能，因此認識了這套工具。但我對影像辨識實在不熟，因此接下來不會討論有關 yolo 的技術或是他的演算法等。有興趣的人可以自行去找它的論文慢慢看。\nYolo 官方網站 : https://pjreddie.com/darknet/yolo/ Yolo 目前最新版為第 3 版\n這篇文章會教你如何在樹梅派 (使用 raspberry pi model 3b) 上安裝及使用 yolo，由於在樹梅派跑 v3 會有問題(下面會提到 )，所以這篇文章的示範會以 yolov2 為主。\n安裝 Yolo Yolo的安裝相當簡單，僅需將 repo clone 下來 make 即可\ngit clone https://github.com/pjreddie/darknet cd darknet make 下載 weights 檔 wget https://pjreddie.com/media/files/yolov2.weights 如果要下載不同的權重檔，請參考 cfg/ 資料夾內的 .cfg 的檔名，將檔名複製下來，附檔名改成 .weights 即可用 wgets 下載\n來試試 yolo 吧 ./darknet detect cfg/yolov2.cfg yolov2.weights data/dog.jpg 以上指令會辨識一張範例圖片，並生成 prediction.png 檔，這個檔案是經過辨識後 yolo 將他辨識出來的物件加上外框而成 ( 實際效果可參考官網 )，如果執行指令都沒問題就表示安裝成功 !\n在執行上述指令後，你可能會發現一個問題: 辨識速度也太慢了吧 ! 但因為樹梅派的運算能力有限，所以這個問題無解。不過 yolo 也有很多 model 可以選，我們可以用 tiny yolo，這個比較輕量的 model 來跑我們的辨識，但缺點就是辨識率沒有這麼高了。而且我看了一下 cfg/ 資料夾，tiny yolo 似乎只有到 v2，第 3 版還沒出來的樣子。另外使用v3 會被 kill 掉 process，個人猜測是樹梅派的記憶體不足導致。\n首先先下載 tiny yolo 的權重檔\nwget https://pjreddie.com/media/files/yolov2-tiny.weights 現在再用 tiny-yolo 跑一次範例圖片測試效果\n./darknet detect cfg/yolov2-tiny.cfg yolov2-tiny.weights data/dog.jpg 以下是我從網路抓隨便抓一個圖片測試的結果\n原始圖片 (圖片來源 ) 使用 yolov2 ( 辨識時間 158 秒 ) 成功辨識出街上的人物！\n","date":"March 28, 2018","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/yolo-on-raspberry/","summary":"簡介 Yolo 是一開放原始碼的影像辨識工具，可以進行圖片、影片、即時影像辨識。因為我的專題需要一個偵測人物走進一個空間的功能，因此認識了這套工具。但我對影像辨識實在不熟，因此接下來不會討論有關 yolo 的技術或是他的演算法等。有興趣的人可以自行去找它的論文慢慢看。\nYolo 官方網站 : https://pjreddie.com/darknet/yolo/ Yolo 目前最新版為第 3 版\n這篇文章會教你如何在樹梅派 (使用 raspberry pi model 3b) 上安裝及使用 yolo，由於在樹梅派跑 v3 會有問題(下面會提到 )，所以這篇文章的示範會以 yolov2 為主。\n安裝 Yolo Yolo的安裝相當簡單，僅需將 repo clone 下來 make 即可\ngit clone https://github.com/pjreddie/darknet cd darknet make 下載 weights 檔 wget https://pjreddie.com/media/files/yolov2.weights 如果要下載不同的權重檔，請參考 cfg/ 資料夾內的 .cfg 的檔名，將檔名複製下來，附檔名改成 .weights 即可用 wgets 下載\n來試試 yolo 吧 ./darknet detect cfg/yolov2.cfg yolov2.weights data/dog.jpg 以上指令會辨識一張範例圖片，並生成 prediction.png 檔，這個檔案是經過辨識後 yolo 將他辨識出來的物件加上外框而成 ( 實際效果可參考官網 )，如果執行指令都沒問題就表示安裝成功 !","tags":["raspberry-pi-3","yolo"],"title":"Yolo on Raspberry Pi 3"},{"categories":[],"contents":"相信有在使用 Git 的各位一定或多或少聽過 Git 的一項好用功能 - stash，中文又稱儲藏，主要是在手邊有臨時工作時用來暫存檔案用的，詳細使用情境可以點這裡 參考。\n當 stash pop 遇到 conflict 時，最簡單的方式就是手動改程式碼並 commit 解決。但問題來了，若在stash裡的是尚未完成的程式碼，這個解決 conflict 的 commit 是不是就顯得多餘？這篇文章就是要解決這個麻煩的情況。\n首先我們照正常解決 conflict 的流程\n看有哪些 conflict 的檔案，並把這些檔案的內容改成你要的樣子 commit 這些變更(建議訊息寫 WIP，因為之後我們不要這個 commit 了) 至此，你應該已經解決了你的 conflict，但是 log 上卻多了一個無用的、只是為了解決 conflict 的 commit。這時候下以下指令:\n$ git reset HEAD^ 這樣就可以無用的 commit 給去掉，並且成功地解決了 conflict。現在你的 git status 應該會跟你 stash push 前的狀態一樣\n原理 git reset HEAD^僅會還原 commit、並不會把程式碼退到上一個版本。我們就是利用這個特性來達成解決conflict但不增加一個commit的目的\n參考資料 Git stash Stack overflow 原文 ","date":"February 10, 2018","hero":"/images/default-hero.jpg","permalink":"https://jay16213.github.io/posts/git-stash-pop-conflict-solution/","summary":"git stash pop conflict solution","tags":["Git"],"title":"Git Stash Pop Conflict 解決方式"}]