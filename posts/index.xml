<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jay's Blog</title><link>https://jay16213.github.io/posts/</link><description>Recent content in Posts on Jay's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Sat, 22 Nov 2025 10:00:00 +0800</lastBuildDate><atom:link href="https://jay16213.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>在 Synology NAS 上用 rclone + pCloud 建立加密雲端備份</title><link>https://jay16213.github.io/posts/rclone-pcloud-backup/</link><pubDate>Sat, 22 Nov 2025 10:00:00 +0800</pubDate><guid>https://jay16213.github.io/posts/rclone-pcloud-backup/</guid><description>使用 Docker 版 rclone 將 Synology NAS 的資料端對端加密後備份到 pCloud，包含配置、headless 授權、排程與驗證建議。</description></item><item><title>[OpenWrt] 使用 Tailscale + AdGuardHome 架設個人 VPN 網域</title><link>https://jay16213.github.io/posts/use-tailscale-adguardhome-to-build-vpn/</link><pubDate>Fri, 04 Oct 2024 16:48:04 +0000</pubDate><guid>https://jay16213.github.io/posts/use-tailscale-adguardhome-to-build-vpn/</guid><description>在 OpenWrt 上使用 Tailscale 架設個人私有網域</description></item><item><title>Binary Search 中的 lower bound &amp; upper bound</title><link>https://jay16213.github.io/posts/algorithm-note/binary-search/</link><pubDate>Mon, 24 Jul 2023 21:56:23 +0800</pubDate><guid>https://jay16213.github.io/posts/algorithm-note/binary-search/</guid><description>前言 c++ 的 STL 有提供兩個跟 binary seach 有關的 function: lower_bound 和 upper_bound, 每次在寫 leetcode 相關的題目時都會一直忘記這兩個 function 的定義，故決定紀錄一下兩者的定義及用法
Include STL lower_bound 和 upper_bound 被定義在 &amp;lt;algorithm&amp;gt; 裡面
#include &amp;lt;algorithm&amp;gt; Lower Bound 找出數列中第一個 大於或等於 target 的位置, 換句話說就是找到 &amp;gt;= target 的最小值的位置
// vector&amp;lt;int&amp;gt; v; // assume v is a sorted array auto it = lower_bound(v.begin(), v.end(), target); int idx = it - v.begin(); Upper Bound 找出數列中第一個 大於 target 的位置, 換句話說就是找到 &amp;gt; target 的最小值的位置
// vector&amp;lt;int&amp;gt; v; // assume v is a sorted array auto it = upper_bound(v.</description></item><item><title>如何在 Local 端測試/執行 Github Actions</title><link>https://jay16213.github.io/posts/test-github-actions-locally/</link><pubDate>Sat, 15 Jul 2023 13:59:32 +0800</pubDate><guid>https://jay16213.github.io/posts/test-github-actions-locally/</guid><description>前言 最近在寫 side project 時想要設定 Github Actions 來自動化編譯跟測試流程，但是按照我之前的經驗是第一次設定 github action 的 workflow 時都會需要不斷修改來達到自己想要的結果，但是如果想要測試的話就會需要一直 commit &amp;amp; push 到 github 上面才有辦法測試，因此這次在設定 workflow 前，我想要找到一個可以不用 push 到 github 就可以在 local 端測試我的 workflow 的工具，這樣我就可以先測試完我的 workflow 後再一次 push 上去 github, 減少設定錯誤的機會，也不用一直繁瑣的 commit &amp;amp; push.
而我找到的工具就是 nektos/act 這個專案，目前在 github 上約有 40k 個 stars，可見這個需求有多大，本篇文就是紀錄如何使用這個工具的筆記。
Install nektos/act 這個專案有提供多種平台以及安裝方式，因為基本上我只會用這個工具來測試我的 workflow 有沒有寫錯，因此我選擇的是安裝官方提供的 GitHub CLI 擴充套件
Install Github CLI Offical installation guide
首先按照官方教學安裝 Github CLI
type -p curl &amp;gt;/dev/null || (sudo apt update &amp;amp;&amp;amp; sudo apt install curl -y) curl -fsSL https://cli.</description></item><item><title>如何在 Synology NAS 使用 non-root user 執行 Docker command</title><link>https://jay16213.github.io/posts/run-docker-command-without-sudo-on-synology-nas/</link><pubDate>Wed, 21 Jun 2023 21:59:18 +0800</pubDate><guid>https://jay16213.github.io/posts/run-docker-command-without-sudo-on-synology-nas/</guid><description>最近因為需要在 Synology NAS 上部署 Coder，container 需要 docker 的運行權限，因為 DSM 的 docker 比較特別，故這裡紀錄一下要如何讓非 root user 也能使用 docker
步驟 首先 ssh 進 NAS 後，使用以下指令來新增 &amp;ldquo;docker&amp;rdquo; 這個 group, 並把需要 docker 權限的 user 加入 docker group
sudo synogroup --add docker sudo synogroup --member docker $USER # 將自己加入 docker group 成功新增後，登入 DSM，可以看到在使用者群組的地方多了一個 docker, 可以加上補充說明這個 group 的作用 (所以理論上應該直接在 DSM 新增 group 就好了，但是我沒試過) 接著將 docker.sock 的 group ownership 從 root 改成 docker
sudo chown root:docker /var/run/docker.sock 改完後重新登入，應該就可以不用加 sudo 就可以執行 docker command 了！</description></item><item><title>[OpenWrt] 如何擴充 squashfs 的可用空間</title><link>https://jay16213.github.io/posts/openwrt-expand-squashfs/</link><pubDate>Mon, 28 Nov 2022 23:22:05 +0800</pubDate><guid>https://jay16213.github.io/posts/openwrt-expand-squashfs/</guid><description>問題 我的 OpenWrt 是安裝在樹梅派上面，採用 squashfs, 安裝完後可以正常使用，但是可用空間只有 100 MB 左右，這是正常現象，如果沒有要安裝很多套件的話其實 100 MB 很夠用了，但是就無法完整利用到整個 SD 卡的空間 (我是裝 32G)；如果要裝 docker 等較大型的套件很快就空間不足了，故本篇文章即是要解決此問題。
其實官方有 Wiki 教學是利用到 losetup 來完成，但是我自己嘗試是沒有成功的，我也懶得研究為甚麼，僅留下連結給有興趣的讀者自行嘗試看看。
解決方式 首先安裝套件，我們需要 cfdisk 和 resize2fs
opkg update opkg install cfdisk resize2fs 安裝好後，可以先用 ls /dev 確認你的 SD 卡的 device 名稱，通常應該會是 /dev/mmcblk0
在 terminal 輸入以下指令
cfdisk /dev/mmcblk0 接著你應該會進入 cfdisk 的互動式介面 可以看到在 /dev/mmcblk0p2 後面有很大的 free space.
接下來，用鍵盤移到 /dev/mmcblk0p2，會出現 Resize 的選項，選擇 Resize 這時系統會要你輸入要劃多大的空間，這裡不用輸入，保留預設值就好，這樣系統就會把所有的 free space 都劃進 /dev/mmcblk0p2，結果如下 完成後輸入 yes 確認變更，這時候從畫面上可以看到 /dev/mmcblk0p2 已經變成 29.</description></item><item><title>Leetcode 隨筆 - 62. Unique Paths</title><link>https://jay16213.github.io/posts/leetcode/leetcode-62/</link><pubDate>Tue, 01 Nov 2022 22:46:23 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-62/</guid><description>題目難度：Medium
題目連結: Unique Paths
題目大綱 給你一個 m x n 的矩陣地圖, 請你找出從座標 (0, 0) 走到 (m-1, n-1) 一共有多少種走法。題目有限制每一次只能往下或往右走一步。
解題思路 解法一 - DP 設計一個 2 維陣列 dp[m][n], 其中 dp[i][j] 對應到座標 (i, j)，代表了從 (0, 0) 走到 (i, j) 一共有多少種走法。
接著從題目的限制我們可以知道，要走到 (i, j) 的話一定要先走到 (i-1, j) 或是 (i, j-1)，然後再往下或往右走一步來到達 (i, j)。
也就是說，走到 (i, j) 的走法數，會等於走到 (i-1, j) 的走法數加上走到 (i, j-1) 的走法數
有了這層關係，我們就可以得出 dp 的公式如下：
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 而一開始要初始化 dp[i][0] = 1 (0 &amp;lt;= i &amp;lt;= m) 以及 dp[0][j] = 1 (0 &amp;lt;= j &amp;lt;= n)，代表從起點開始，一路往右或往下都只有一種走法</description></item><item><title>Leetcode 隨筆 - 139. Word Break</title><link>https://jay16213.github.io/posts/leetcode/leetcode-139/</link><pubDate>Sun, 30 Oct 2022 00:35:01 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-139/</guid><description>題目難度：Medium
題目連結: Word Break
題目大綱 給定一個字串 s 和一個字串陣列 wordDict, 請你判斷是否有辦法
程式碼 解法一 這是我看完 NeetCode 影片的前半段的解題思路後想出來的解法
class Solution { private: vector&amp;lt;int&amp;gt; word_len; int s_len; vector&amp;lt;int&amp;gt; dp; public: void solve(string&amp;amp; s, int idx, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { if (idx &amp;gt;= s_len) { dp[s_len] = 1; return; } if (dp[idx] != -1) return; for (int i = 0; i &amp;lt; wordDict.size(); i++) { if (s.compare(idx, word_len[i], wordDict[i]) == 0) { solve(s, idx + word_len[i], wordDict); if (dp[s_len] == 1) return; } } dp[idx] = 0; } bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { word_len.</description></item><item><title>Leetcode 隨筆 - 152. Maximum Product Subarray</title><link>https://jay16213.github.io/posts/leetcode/leetcode-152/</link><pubDate>Sat, 29 Oct 2022 14:10:08 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-152/</guid><description>題目難度：Medium
題目連結: Maximum Product Subarray
題目大綱 給你一個整數陣列, 找出擁有最大乘積的子陣列 (contiguous non-empty subarray)
程式碼 class Solution { public: int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = nums[0]; int max_product = 1; int min_product = 1; int t1, t2; for (int i = 0; i &amp;lt; nums.size(); i++) { t1 = max_product * nums[i]; t2 = min_product * nums[i]; max_product = max(t1, max(t2, nums[i])); min_product = min(t1, min(t2, nums[i])); ans = max(max_product, ans); } return ans; } };</description></item><item><title>Leetcode 隨筆 - 199. Binary Tree Right Side View</title><link>https://jay16213.github.io/posts/leetcode/leetcode-199/</link><pubDate>Mon, 11 Jul 2022 21:48:41 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-199/</guid><description>題目難度：Medium
題目連結: Binary Tree Right Side View
題目大綱 給你一個 binary tree, 請你找出：從右邊看這棵樹，能看到的 node 有哪些。
解題思路 這題翻譯過後就是，請你找出此 binary tree 的每一層的最右邊的 node，所以我們只需要使用 level order traverse 的方式把 tree 掃過一遍抓出每層最右邊的 node 就行了！
程式碼 實作採用 C++ STL 的 queue, 遍歷時加上每個 node 的 level 資訊，當每掃到新的 level 時就會把該 node 加進 ans 裡面並更新 level 資訊；再來因為我們需要最右邊的 node, 所以 traverse 順序改成先掃右邊的 subtree 再掃左邊 subtree 的方式比較方便實作。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;int&amp;gt; rightSideView(TreeNode* root) { queue&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; q; pair&amp;lt;TreeNode*, int&amp;gt; node; vector&amp;lt;int&amp;gt; ans; int cur_level = -1; if (root == NULL) return vector&amp;lt;int&amp;gt;(); q.</description></item><item><title>Leetcode 隨筆 - 665. Non-decreasing Array</title><link>https://jay16213.github.io/posts/leetcode/leetcode-665/</link><pubDate>Sat, 25 Jun 2022 13:44:48 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-665/</guid><description>題目難度：Medium
題目連結: Non-decreasing Array
題目大綱 給你一個陣列 nums，請你檢查是否可以在 &amp;ldquo;最多修改一個元素的值&amp;rdquo; 的限制下，把這個陣列變成一個非遞減陣列 (原來就已經是非遞減陣列也可以算通過檢查)
非遞減定義： nums[i] &amp;lt;= nums[i+1], where 0 &amp;lt;= i &amp;lt;= nums.size()-2
解題思路 首先需要把陣列從頭開始掃描一遍，遇到 nums[i+1] &amp;lt; nums[i] 時停下來檢查是否可以修改元素值來完成題目要求，如果可以改，那就紀錄本次修改。所以我們可以用一個 counter 來記錄修改次數，而若修改次數大於 1 次就可以提前結束不用再往後檢查了。
接下來重點就是：要怎麼確認可以修改(改成非遞減)？ 這裡可以分成幾個 case 來討論：
Case 1. 陣列的開頭 or 結尾發生遞減情況 也就是 nums[0] &amp;gt; nums[1] or nums[nums.size()-1] &amp;gt; nums[nums.size()-2]，這時候一定可以修改，因為只要把陣列頭的值往下修或把陣列尾的值往上調就可以了，所以直接更新 counter (counter++) 即可。
Case 2. 陣列中間發生遞減情況 這時候發生了 nums[i+1] &amp;lt; nums[i]，為了判斷是否能夠只改一個值就能改成非遞減陣列，我們必須額外再抓出 nums[i-1] &amp;amp; nums[i+2] 這兩個元素來幫助我們判斷。
首先第一項檢查
nums[i+2] 是否大於等於 nums[i-1] ?
因為若這個條件不符合，代表除了 nums[i] 跟 nums[i+1] 之外，在 nums[i+2] 這個位置又讓陣列發生了遞減情況，所以至少要改兩個地方，這樣絕對達不到題目要求，因此我們可以提早結束判斷、回傳失敗結果。</description></item><item><title>LeetCode 隨筆 - 74. Search a 2D Matrix</title><link>https://jay16213.github.io/posts/leetcode/leetcode-74/</link><pubDate>Sat, 18 Jun 2022 23:38:19 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-74/</guid><description>題目難度：Medium
題目連結: Search a 2D Matrix
題目大綱 給你一個 m x n 的整數二維陣列和一個 value target，要你判斷 target 是否在這個陣列中。 題目保證這個二維陣列：
每個 row 的數字的順序已經由小到大排序過了 每個 row 的第一個數字一定比上一個 row 的最後一個數字還要大 解題思路 由題目可知，將這個二維陣列按照 row 展開成一維陣列後就是一個排序過的 array，所以我們就可以直接用 二分搜 (Binary Search) 來找 target。 需要注意的是傳入的是二維陣列，所以在寫 binary search 的時候需要轉換一維 &amp;amp; 二維之間的坐標系
一維 &amp;amp; 二維坐標系轉換範例： 假設我們要轉換一維陣列的 index i 到一個 m x n (m rows * n columns) 的二維陣列的 index (row, col)
row = i / n; col = i % n; 程式碼 binary search 可以使用迴圈或遞迴的方式來實作，以下提供兩種版本供讀者參考</description></item><item><title>LeetCode 隨筆 - 203. Remove Linked List Elements</title><link>https://jay16213.github.io/posts/leetcode/leetcode-203/</link><pubDate>Sun, 19 Sep 2021 01:31:18 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-203/</guid><description>題目難度：Easy
題目大綱 給你一個單向的 linked list, 再給你一個數字 val, 移除該 linked list 中所有 Node.val == val 的 node 並回傳處理完後的 linked list.
解題思路 分兩步驟來解：
首先檢查 head node 是否符合條件，若 head 符合條件則一直執行 head = head-&amp;gt;next ，不斷地把 head 截掉直到 head 是有效的 (Node.val != val) 接著一個 node 一個 node 去歷遍整個 list, 每個 node 的操作為：看下一個 node (後續以 next node 代稱) 是否符合條件，若符合的話就把自己的 next 指標接到 next node 的 next 指標 (也就是移除該 next node)，並繼續比較新的 next node (也就是回到第 2 步剛開始的操作)，否則繼續往下 loop 剩餘的 node 理論上移除掉的 node 要記得 free 掉不然會 memory leak, 不過這只是練習而已 LeetCode 好像也沒檢查這個，有沒有 free 掉都可以 AC</description></item><item><title>Raspberry Pi 透過 Serial Port 連線 - 踩雷筆記</title><link>https://jay16213.github.io/posts/raspberry-serial-port-login/</link><pubDate>Wed, 10 Feb 2021 00:14:53 +0800</pubDate><guid>https://jay16213.github.io/posts/raspberry-serial-port-login/</guid><description>最近因為想要從 serial port 登入樹梅派而入手了一個 USB 轉 TTL 傳輸線，沒想到設定過程踩了不少雷，故寫了這篇作為提醒用。
我是從電子材料行買的，型號為CONCBLUSBTTL，使用 PL2303TA 晶片
理論上 win10 可以自動抓可以用的驅動，不需要特別下載。但如果有問題的話還是可以從晶片製造商的驅動程式下載頁面下載最新的驅動。解壓縮後除了驅動程式外還有一個小程式可以用來檢查晶片型號。
這裡遇到我採的第一個雷 (自己雷)：在我一開始無法順利設定時，經爬文得知，由於舊款晶片 (PL2303HX 系列) 有偽造情形，故 win10 自動抓的驅動並不支援該款晶片的產品，需要下載舊版驅動才行，我還以為自己真幸運在 2021 還買得到舊款晶片，大費周章跑去前人的 blog 載舊版驅動，結果還是不行；又因為在舊版驅動下跑上面原廠提供的晶片型號檢查程式會將我的傳輸線誤判為 PL2303XA/PL2303HXA
害我誤以為自己真的買到 PL2303HX 晶片，一直往錯誤的方向 google。後來完全解決不了，改用新版驅動再測最後一次，想說不行就要放棄這條線了，才發現原來都是驅動搞的鬼。
這裡提醒一下接線的注意事項，傳輸線和樹梅派的 TX/RX 要反著接，也就是 線的 TX 要接到 Pi 的 RX，線的 RX 要接到 Pi 的 TX。GND 當然也要記得接。我這條線還有一個 5V 線，接上去後可以為 Pi 供電並開機，不過看其他人文章表示不一定要接這條線，而且我怕 GPIO 的供電不穩 (我用的是 pi 4, pi 4 在供電不足的情況下 wifi 會無法連線，就算能順利連上品質也不好，所以供電一定要足) 所以就沒接了。
解決完驅動問題接下來就剩連線設定了，這裡是第二個要注意的地方，所有參數都要設定正確不然就會連不上！像是 speed，網路上的教學大都多是教人設定為 115200，但我的這條線，在裝置管理員的預設值為 9600，所以連線時要設 9600；還有 flow control 不論是 putty 或是 MobaXterm 預設都會是 Xon/Xoff，同樣與這條線的預設值不符，要記得關掉。</description></item><item><title>OpenCV on Raspberry Pi 3</title><link>https://jay16213.github.io/posts/opencv-on-raspberry/</link><pubDate>Mon, 02 Apr 2018 23:44:05 +0800</pubDate><guid>https://jay16213.github.io/posts/opencv-on-raspberry/</guid><description>簡介 OpenCV 是由 intel 主導的一個電腦視覺的跨平台 library，可以用在許多應用上。yolo real-time detection ( 關於 yolo 的安裝與使用可以看我之前寫的文章: Yolo on Raspberry Pi 3 ) 就有用到 OpenCV。這篇文章就是要教如何在樹梅派上自行編譯、安裝 OpenCV 函式庫。雖然是強調在樹梅派上安裝 OpenCV，不過都是流程都是按照官方文件的 Linux 平台安裝教學走，所以只要是 Linux 平台都可以理論上都可以照著本篇文章來安裝 OpenCV！（當然裡面有些指令可能會不太一樣，例如 apt-get 是 debian 流派，如果是 redhat 就要換成 yum）
要提醒的是 OpenCV 還有很多安裝的參數可以調整（例如對更多 Python / Java 的支援等）但是這篇文章目的是基本的 OpenCV 安裝，所以會略過那些非必要的步驟，需要更多自訂設定的人可以點上面的官方教學自行研究。
安裝教學 首先安裝套件 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # 這行的套件非必要，可裝可不裝 從 Github 上把原始碼 clone 下來，並進入 opencv 資料夾 cd ~/ # 可自行選擇 clone 的位置 git clone https://github.</description></item><item><title>Yolo on Raspberry Pi 3</title><link>https://jay16213.github.io/posts/yolo-on-raspberry/</link><pubDate>Wed, 28 Mar 2018 00:57:00 +0800</pubDate><guid>https://jay16213.github.io/posts/yolo-on-raspberry/</guid><description>簡介 Yolo 是一開放原始碼的影像辨識工具，可以進行圖片、影片、即時影像辨識。因為我的專題需要一個偵測人物走進一個空間的功能，因此認識了這套工具。但我對影像辨識實在不熟，因此接下來不會討論有關 yolo 的技術或是他的演算法等。有興趣的人可以自行去找它的論文慢慢看。
Yolo 官方網站 : https://pjreddie.com/darknet/yolo/ Yolo 目前最新版為第 3 版
這篇文章會教你如何在樹梅派 (使用 raspberry pi model 3b) 上安裝及使用 yolo，由於在樹梅派跑 v3 會有問題(下面會提到 )，所以這篇文章的示範會以 yolov2 為主。
安裝 Yolo Yolo的安裝相當簡單，僅需將 repo clone 下來 make 即可
git clone https://github.com/pjreddie/darknet cd darknet make 下載 weights 檔 wget https://pjreddie.com/media/files/yolov2.weights 如果要下載不同的權重檔，請參考 cfg/ 資料夾內的 .cfg 的檔名，將檔名複製下來，附檔名改成 .weights 即可用 wgets 下載
來試試 yolo 吧 ./darknet detect cfg/yolov2.cfg yolov2.weights data/dog.jpg 以上指令會辨識一張範例圖片，並生成 prediction.png 檔，這個檔案是經過辨識後 yolo 將他辨識出來的物件加上外框而成 ( 實際效果可參考官網 )，如果執行指令都沒問題就表示安裝成功 !</description></item><item><title>Git Stash Pop Conflict 解決方式</title><link>https://jay16213.github.io/posts/git-stash-pop-conflict-solution/</link><pubDate>Sat, 10 Feb 2018 23:59:38 +0800</pubDate><guid>https://jay16213.github.io/posts/git-stash-pop-conflict-solution/</guid><description>git stash pop conflict solution</description></item></channel></rss>