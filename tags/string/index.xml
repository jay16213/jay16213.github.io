<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Jay's Blog</title><link>https://jay16213.github.io/tags/string/</link><description>Recent content in String on Jay's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Sun, 30 Oct 2022 00:35:01 +0800</lastBuildDate><atom:link href="https://jay16213.github.io/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 隨筆 - 139. Word Break</title><link>https://jay16213.github.io/posts/leetcode/leetcode-139/</link><pubDate>Sun, 30 Oct 2022 00:35:01 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-139/</guid><description>題目難度：Medium
題目連結: Word Break
題目大綱 給定一個字串 s 和一個字串陣列 wordDict, 請你判斷是否有辦法
程式碼 解法一 這是我看完 NeetCode 影片的前半段的解題思路後想出來的解法
class Solution { private: vector&amp;lt;int&amp;gt; word_len; int s_len; vector&amp;lt;int&amp;gt; dp; public: void solve(string&amp;amp; s, int idx, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { if (idx &amp;gt;= s_len) { dp[s_len] = 1; return; } if (dp[idx] != -1) return; for (int i = 0; i &amp;lt; wordDict.size(); i++) { if (s.compare(idx, word_len[i], wordDict[i]) == 0) { solve(s, idx + word_len[i], wordDict); if (dp[s_len] == 1) return; } } dp[idx] = 0; } bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { word_len.</description></item></channel></rss>