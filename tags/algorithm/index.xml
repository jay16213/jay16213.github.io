<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Jay's Blog</title><link>https://jay16213.github.io/tags/algorithm/</link><description>Recent content in Algorithm on Jay's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Mon, 24 Jul 2023 21:56:23 +0800</lastBuildDate><atom:link href="https://jay16213.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Search 中的 lower bound &amp; upper bound</title><link>https://jay16213.github.io/posts/algorithm-note/binary-search/</link><pubDate>Mon, 24 Jul 2023 21:56:23 +0800</pubDate><guid>https://jay16213.github.io/posts/algorithm-note/binary-search/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>c++ 的 STL 有提供兩個跟 binary seach 有關的 function: &lt;code>lower_bound&lt;/code> 和 &lt;code>upper_bound&lt;/code>, 每次在寫 leetcode 相關的題目時都會一直忘記這兩個 function 的定義，故決定紀錄一下兩者的定義及用法&lt;/p>
&lt;h4 id="include-stl">Include STL&lt;/h4>
&lt;p>&lt;code>lower_bound&lt;/code> 和 &lt;code>upper_bound&lt;/code> 被定義在 &lt;code>&amp;lt;algorithm&amp;gt;&lt;/code> 裡面&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="lower-bound">Lower Bound&lt;/h3>
&lt;p>找出數列中第一個 &lt;strong>大於或等於&lt;/strong> target 的位置, 換句話說就是找到 &lt;code>&amp;gt;= target&lt;/code> 的最小值的位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// vector&amp;lt;int&amp;gt; v;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// assume v is a sorted array
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> lower_bound(v.begin(), v.end(), target);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> it &lt;span style="color:#f92672">-&lt;/span> v.begin();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="upper-bound">Upper Bound&lt;/h3>
&lt;p>找出數列中第一個 &lt;strong>大於&lt;/strong> target 的位置, 換句話說就是找到 &lt;code>&amp;gt; target&lt;/code> 的最小值的位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// vector&amp;lt;int&amp;gt; v;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// assume v is a sorted array
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">auto&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> upper_bound(v.begin(), v.end(), target) &lt;span style="color:#f92672">-&lt;/span> v.begin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> it &lt;span style="color:#f92672">-&lt;/span> v.begin();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;p>&lt;code>lower_bound&lt;/code> 和 &lt;code>upper_bound&lt;/code> 都會回傳 對應型態的 iterator, 如果傳入的 sequence 找不到目標值，就會回傳 &lt;code>v.end()&lt;/code>&lt;/p></description></item></channel></rss>