<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary-Search on Jay's Blog</title><link>https://jay16213.github.io/tags/binary-search/</link><description>Recent content in Binary-Search on Jay's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Mon, 24 Jul 2023 21:56:23 +0800</lastBuildDate><atom:link href="https://jay16213.github.io/tags/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Search 中的 lower bound &amp; upper bound</title><link>https://jay16213.github.io/posts/algorithm-note/binary-search/</link><pubDate>Mon, 24 Jul 2023 21:56:23 +0800</pubDate><guid>https://jay16213.github.io/posts/algorithm-note/binary-search/</guid><description>前言 c++ 的 STL 有提供兩個跟 binary seach 有關的 function: lower_bound 和 upper_bound, 每次在寫 leetcode 相關的題目時都會一直忘記這兩個 function 的定義，故決定紀錄一下兩者的定義及用法
Include STL lower_bound 和 upper_bound 被定義在 &amp;lt;algorithm&amp;gt; 裡面
#include &amp;lt;algorithm&amp;gt; Lower Bound 找出數列中第一個 大於或等於 target 的位置, 換句話說就是找到 &amp;gt;= target 的最小值的位置
// vector&amp;lt;int&amp;gt; v; // assume v is a sorted array auto it = lower_bound(v.begin(), v.end(), target); int idx = it - v.begin(); Upper Bound 找出數列中第一個 大於 target 的位置, 換句話說就是找到 &amp;gt; target 的最小值的位置
// vector&amp;lt;int&amp;gt; v; // assume v is a sorted array auto it = upper_bound(v.</description></item><item><title>LeetCode 隨筆 - 74. Search a 2D Matrix</title><link>https://jay16213.github.io/posts/leetcode/leetcode-74/</link><pubDate>Sat, 18 Jun 2022 23:38:19 +0800</pubDate><guid>https://jay16213.github.io/posts/leetcode/leetcode-74/</guid><description>題目難度：Medium
題目連結: Search a 2D Matrix
題目大綱 給你一個 m x n 的整數二維陣列和一個 value target，要你判斷 target 是否在這個陣列中。 題目保證這個二維陣列：
每個 row 的數字的順序已經由小到大排序過了 每個 row 的第一個數字一定比上一個 row 的最後一個數字還要大 解題思路 由題目可知，將這個二維陣列按照 row 展開成一維陣列後就是一個排序過的 array，所以我們就可以直接用 二分搜 (Binary Search) 來找 target。 需要注意的是傳入的是二維陣列，所以在寫 binary search 的時候需要轉換一維 &amp;amp; 二維之間的坐標系
一維 &amp;amp; 二維坐標系轉換範例： 假設我們要轉換一維陣列的 index i 到一個 m x n (m rows * n columns) 的二維陣列的 index (row, col)
row = i / n; col = i % n; 程式碼 binary search 可以使用迴圈或遞迴的方式來實作，以下提供兩種版本供讀者參考</description></item></channel></rss>